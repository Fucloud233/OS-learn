# Week12作业

## 循环等待
> 文件路径: [circular_wait.c](./circular_wait.c), [multiple_locks.c](./multiple_locks.c)

创建2个线程使用2个互斥锁mutex
* 线程1使用顺序：1 -> 2
* 线程2使用顺序：2 -> 1

当两个线程都同时给自己的第1个锁上锁时，发生交叉，则产生死锁。**死锁现象不会一定产生。**

但是当在给自己的第1个锁上锁后，添加等待代码`sleep(1)`，则一定会发生死锁。

## 共享资源
> 文件路径: [shared_resources.c](./shared_resources.c)

通过锁控制两个线程对同一份资源文件的读取。。

## 优先级反转
> 文件路径: [priority_inversion.c](./priority_inversion.c)

主体代码部分与共享资源相同，但是两个线程具有不同优先级的线程。如果优先级的线程先运行，会循环等待，发生死锁。

**解决方法：** 在优先级的线程等待时尝试放锁，这样高优先级的线程则能够进入线程。

## 银行家算法

### 检测安全
首先做1个假设， 如果在现在这种情况下，所有线程都可以按顺序得到自己的资源，那么这就是安全的。

### 运行
运行的时候还是要计算可用资源和需要资源的大小关系，上面的假设都是在资源释放后满足的。

### 哲学家问题
> 5个哲学家只有5根筷子的问题

5个哲学家对应5个线程，5根筷子对应5把锁。解决问题的思路就很上面相同
